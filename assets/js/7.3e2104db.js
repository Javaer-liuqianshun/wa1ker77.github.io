(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{176:function(e,t,s){e.exports=s.p+"assets/img/xingneng.86b908f9.jpg"},177:function(e,t,s){e.exports=s.p+"assets/img/bingfa.0b4efb8f.jpg"},203:function(e,t,s){"use strict";s.r(t);var a=[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"redis笔记"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis笔记","aria-hidden":"true"}},[e._v("#")]),e._v(" Redis笔记")]),e._v(" "),a("p",[e._v("百度百科：Redis是一个key - value存储系统。支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set:有序集合)和hash(哈希类型)")]),e._v(" "),a("p",[e._v("Redis笔记从一下几点阐述")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("为什么使用 Redis")])]),e._v(" "),a("li",[a("strong",[e._v("使用 Redis 有什么缺点")])]),e._v(" "),a("li",[a("strong",[e._v("单线程的 Redis 为什么这么快")])]),e._v(" "),a("li",[a("strong",[e._v("Redis 的数据类型，以及每种数据类型的使用场景")])]),e._v(" "),a("li",[a("strong",[e._v("Redis 的过期策略以及内存淘汰机制")])]),e._v(" "),a("li",[a("strong",[e._v("Redis 和数据库双写一致性问题")])]),e._v(" "),a("li",[a("strong",[e._v("如何应对缓存穿透和缓存雪崩问题")])]),e._v(" "),a("li",[a("strong",[e._v("如何解决 Redis 的并发竞争 Key 问题")])])]),e._v(" "),a("h2",{attrs:{id:"为什么使用redis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用redis","aria-hidden":"true"}},[e._v("#")]),e._v(" 为什么使用Redis")]),e._v(" "),a("p",[e._v("在项目中Redis，主要从两个角度考虑：性能和并发。其实Redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件，如ZooKeeper代替，并不是非要使用Redis。因此，这个问题主要从性能和并发两个角度考虑。")]),e._v(" "),a("h3",{attrs:{id:"性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能","aria-hidden":"true"}},[e._v("#")]),e._v(" 性能")]),e._v(" "),a("div",{staticStyle:{"text-align":"center"}},[a("img",{staticStyle:{height:"250px",width:"500px"},attrs:{src:s(176)}})]),e._v(" "),a("p",[e._v("如图所示，当碰到执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存中。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。")]),e._v(" "),a("h3",{attrs:{id:"并发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发","aria-hidden":"true"}},[e._v("#")]),e._v(" 并发")]),e._v(" "),a("div",{staticStyle:{"text-align":"center"}},[a("img",{staticStyle:{height:"250px",width:"500px"},attrs:{src:s(177)}})]),e._v(" "),a("p",[e._v("如图所示，当大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用Redis做一个缓冲作用，让请求先访问Redis，而不是直接访问数据库。")]),e._v(" "),a("h2",{attrs:{id:"使用redis有什么缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用redis有什么缺点","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用Redis有什么缺点")]),e._v(" "),a("p",[e._v("使用Redis基本会碰到一些问题，最常见的四个问题："),a("code",[e._v("1.缓存和数据库双写一致性问题；2.缓存雪崩问题；3.缓存击穿问题；4.缓存的并发竞争问题")])]),e._v(" "),a("h2",{attrs:{id:"单线程的redis为什么这么快"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单线程的redis为什么这么快","aria-hidden":"true"}},[e._v("#")]),e._v(" 单线程的Redis为什么这么快")]),e._v(" "),a("p",[e._v("其实Redis是单线程工作模式， Redis读写快的原因主要有："),a("code",[e._v("1.纯内存操作；2.单线程操作，避免了频繁的上下文切换；3.采用了非阻塞I/O多路复用机制")]),e._v("。")]),e._v(" "),a("p",[e._v("I/O多路复用的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。")]),e._v(" "),a("h2",{attrs:{id:"redis-的数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-的数据类型","aria-hidden":"true"}},[e._v("#")]),e._v(" Redis 的数据类型")]),e._v(" "),a("p",[e._v("开头介绍Redis是一个Key - Value存储系统，value类型有String、Set、Sorted Set、Hash和List。这里介绍Redis中的五种数据类型及其每种数据类型使用的场景。")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("String：")]),e._v(" "),a("p",[e._v("最常规的set/get操作，value可以是String，也可以是数字。一般做一些复杂的计数功能的缓存。")])]),e._v(" "),a("li",[a("p",[e._v("Hash：")]),e._v(" "),a("p",[e._v("value存放对象。")])]),e._v(" "),a("li",[a("p",[e._v("List：")]),e._v(" "),a("p",[e._v("使用 List 的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。")])]),e._v(" "),a("li",[a("p",[e._v("Set：")]),e._v(" "),a("p",[e._v("因为 Set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。 就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。")])]),e._v(" "),a("li",[a("p",[e._v("Sorted Set：")]),e._v(" "),a("p",[e._v("Sorted Set多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。")])])]),e._v(" "),a("h2",{attrs:{id:"redis-的过期策略以及内存淘汰机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-的过期策略以及内存淘汰机制","aria-hidden":"true"}},[e._v("#")]),e._v(" Redis 的过期策略以及内存淘汰机制")]),e._v(" "),a("p",[e._v("这个问题相当重要，到底 Redis 有没用到家，这个问题就可以看出来。")]),e._v(" "),a("p",[e._v("比如你 Redis 只能存 5G 数据，可是你写了 10G，那会删 5G 的数据。怎么删的，这个问题思考过么？")]),e._v(" "),a("p",[a("strong",[e._v("回答：Redis 采用的是定期删除+惰性删除策略。")])]),e._v(" "),a("p",[e._v("还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?")]),e._v(" "),a("h3",{attrs:{id:"为什么不用定时删除策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么不用定时删除策略","aria-hidden":"true"}},[e._v("#")]),e._v(" 为什么不用定时删除策略")]),e._v(" "),a("p",[e._v("定时删除，用一个定时器来负责监视 Key，过期则自动删除。虽然内存及时释放，但是十分消耗 CPU 资源。在大并发请求下，CPU 要将时间应用在处理请求，而不是删除 Key，因此没有采用这一策略。")]),e._v(" "),a("h3",{attrs:{id:"定期删除-惰性删除是如何工作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定期删除-惰性删除是如何工作","aria-hidden":"true"}},[e._v("#")]),e._v(" 定期删除+惰性删除是如何工作")]),e._v(" "),a("p",[e._v("定期删除，Redis 默认每个 100ms 检查，是否有过期的 Key，有过期 Key 则删除。需要说明的是，Redis 不是每个 100ms 将所有的 Key 检查一次，而是随机抽取进行检查(如果每隔 100ms，全部 Key 进行检查，Redis 岂不是卡死)。因此，如果只采用定期删除策略，会导致很多 Key 到时间没有删除。于是，惰性删除派上用场。也就是说在你获取某个 Key 的时候，Redis 会检查一下，这个 Key 如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。")]),e._v(" "),a("p",[e._v("采用定期删除+惰性删除就没其他问题了么?")]),e._v(" "),a("p",[a("strong",[e._v("回答：不是的，如果定期删除没删除 Key。然后你也没即时去请求 Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高。那么就应该采用内存淘汰机制。")])]),e._v(" "),a("h3",{attrs:{id:"内存淘汰机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存淘汰机制","aria-hidden":"true"}},[e._v("#")]),e._v(" 内存淘汰机制")]),e._v(" "),a("ul",[a("li",[a("p",[a("strong",[e._v("noeviction")]),e._v(" ：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("allkeys-lru")]),e._v(" ：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。"),a("strong",[e._v("推荐使用，目前项目在用这种。")])])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("allkeys-random")]),e._v(" ：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("volatile-lru")]),e._v(" ：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("volatile-random")]),e._v(" ：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。")])]),e._v(" "),a("li",[a("p",[a("strong",[e._v("volatile-ttl")]),e._v(" ：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。")])])]),e._v(" "),a("h2",{attrs:{id:"redis-和数据库双写一致性问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-和数据库双写一致性问题","aria-hidden":"true"}},[e._v("#")]),e._v(" Redis 和数据库双写一致性问题")]),e._v(" "),a("p",[e._v("一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。另外，我们所做的方案从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。")]),e._v(" "),a("p",[a("strong",[e._v("回答：首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列")]),e._v("。")]),e._v(" "),a("h2",{attrs:{id:"如何应对缓存穿透和缓存雪崩问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何应对缓存穿透和缓存雪崩问题","aria-hidden":"true"}},[e._v("#")]),e._v(" 如何应对缓存穿透和缓存雪崩问题")]),e._v(" "),a("p",[a("strong",[e._v("缓存穿透")]),e._v("，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。")]),e._v(" "),a("p",[e._v("缓存穿透解决方案："),a("code",[e._v("1.利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试；2.采用异步更新策略，无论 Key 是否取到值，都直接返回。Value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作；3.提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 Key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。")])]),e._v(" "),a("p",[a("strong",[e._v("缓存雪崩")]),e._v("，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。")]),e._v(" "),a("p",[e._v("缓存雪崩解决方案："),a("code",[e._v("1.给缓存的失效时间，加上一个随机值，避免集体失效；2.使用互斥锁，但是该方案吞吐量明显下降了；3.双缓存。我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。自己做缓存预热操作。然后细分以下几个小点：从缓存 A 读数据库，有则直接返回；A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程，更新线程同时更新缓存 A 和缓存 B。")])]),e._v(" "),a("h2",{attrs:{id:"如何解决-redis-的并发竞争-key-问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何解决-redis-的并发竞争-key-问题","aria-hidden":"true"}},[e._v("#")]),e._v(" 如何解决 Redis 的并发竞争 Key 问题")]),e._v(" "),a("p",[e._v("这个问题大致就是，同时有多个子系统去 Set 一个 Key。这个时候大家思考过要注意什么呢？")]),e._v(" "),a("h3",{attrs:{id:"如果对这个-key-操作，不要求顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如果对这个-key-操作，不要求顺序","aria-hidden":"true"}},[e._v("#")]),e._v(" 如果对这个 Key 操作，不要求顺序")]),e._v(" "),a("p",[e._v("这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可，比较简单。")]),e._v(" "),a("h3",{attrs:{id:"如果对这个-key-操作，要求顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如果对这个-key-操作，要求顺序","aria-hidden":"true"}},[e._v("#")]),e._v(" 如果对这个 Key 操作，要求顺序")]),e._v(" "),a("p",[e._v("假设有一个 key1，系统 A 需要将 key1 设置为 valueA，系统 B 需要将 key1 设置为 valueB，系统 C 需要将 key1 设置为 valueC。期望按照 key1 的 value 值按照 valueA > valueB > valueC 的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("系统A key 1 {valueA  3:00}\n系统B key 1 {valueB  3:05}\n系统C key 1 {valueC  3:10}\n")])])]),a("p",[e._v("那么，假设这会系统 B 先抢到锁，将 key1 设置为"),a("code",[e._v("{valueB 3:05}")]),e._v("。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了，以此类推。")])])}],v=s(0),r=Object(v.a)({},function(){this.$createElement;this._self._c;return this._m(0)},a,!1,null,null,null);r.options.__file="README.md";t.default=r.exports}}]);