<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis笔记 | wa1ker77笔记</title>
    <meta name="description" content="在你尝试之前，你永远不知道你能做什么。">
    <link rel="icon" href="/hero.png">
    
    <link rel="preload" href="/assets/css/0.styles.347da699.css" as="style"><link rel="preload" href="/assets/js/app.05c1b046.js" as="script"><link rel="preload" href="/assets/js/7.3e2104db.js" as="script"><link rel="prefetch" href="/assets/js/10.8220daa2.js"><link rel="prefetch" href="/assets/js/11.bd401985.js"><link rel="prefetch" href="/assets/js/12.ff7b17b7.js"><link rel="prefetch" href="/assets/js/13.a2c35f42.js"><link rel="prefetch" href="/assets/js/14.5e26248d.js"><link rel="prefetch" href="/assets/js/15.d8bad41d.js"><link rel="prefetch" href="/assets/js/16.1087d107.js"><link rel="prefetch" href="/assets/js/17.69f2e300.js"><link rel="prefetch" href="/assets/js/18.6dabcbfb.js"><link rel="prefetch" href="/assets/js/19.e1513b6c.js"><link rel="prefetch" href="/assets/js/2.0829d99a.js"><link rel="prefetch" href="/assets/js/20.4c86d8a1.js"><link rel="prefetch" href="/assets/js/21.597e0b63.js"><link rel="prefetch" href="/assets/js/22.8cace07b.js"><link rel="prefetch" href="/assets/js/23.a154b9c1.js"><link rel="prefetch" href="/assets/js/24.92342fa4.js"><link rel="prefetch" href="/assets/js/25.cf4ec5aa.js"><link rel="prefetch" href="/assets/js/26.7f25323f.js"><link rel="prefetch" href="/assets/js/27.26917417.js"><link rel="prefetch" href="/assets/js/28.4f85ad18.js"><link rel="prefetch" href="/assets/js/29.4449b747.js"><link rel="prefetch" href="/assets/js/3.cbfbc2ec.js"><link rel="prefetch" href="/assets/js/30.94a28d82.js"><link rel="prefetch" href="/assets/js/31.2fb64ce8.js"><link rel="prefetch" href="/assets/js/32.272c8932.js"><link rel="prefetch" href="/assets/js/33.c9439bc1.js"><link rel="prefetch" href="/assets/js/34.dbd066fb.js"><link rel="prefetch" href="/assets/js/35.a3059914.js"><link rel="prefetch" href="/assets/js/36.d9187cf5.js"><link rel="prefetch" href="/assets/js/37.2872d3da.js"><link rel="prefetch" href="/assets/js/4.3bad2042.js"><link rel="prefetch" href="/assets/js/5.4a4e87cf.js"><link rel="prefetch" href="/assets/js/6.c16239e7.js"><link rel="prefetch" href="/assets/js/8.f78b551f.js"><link rel="prefetch" href="/assets/js/9.c14e584e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.347da699.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">wa1ker77笔记</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/rule/" class="nav-link">编程规范</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">数据结构与算法</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/leetcode/" class="nav-link">LeetCode</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/wa1ker77" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/rule/" class="nav-link">编程规范</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">数据结构与算法</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/leetcode/" class="nav-link">LeetCode</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/wa1ker77" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <!----> </div> <div class="page"> <div class="content"><h1 id="redis笔记"><a href="#redis笔记" aria-hidden="true" class="header-anchor">#</a> Redis笔记</h1> <p>百度百科：Redis是一个key - value存储系统。支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set:有序集合)和hash(哈希类型)</p> <p>Redis笔记从一下几点阐述</p> <ul><li><strong>为什么使用 Redis</strong></li> <li><strong>使用 Redis 有什么缺点</strong></li> <li><strong>单线程的 Redis 为什么这么快</strong></li> <li><strong>Redis 的数据类型，以及每种数据类型的使用场景</strong></li> <li><strong>Redis 的过期策略以及内存淘汰机制</strong></li> <li><strong>Redis 和数据库双写一致性问题</strong></li> <li><strong>如何应对缓存穿透和缓存雪崩问题</strong></li> <li><strong>如何解决 Redis 的并发竞争 Key 问题</strong></li></ul> <h2 id="为什么使用redis"><a href="#为什么使用redis" aria-hidden="true" class="header-anchor">#</a> 为什么使用Redis</h2> <p>在项目中Redis，主要从两个角度考虑：性能和并发。其实Redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件，如ZooKeeper代替，并不是非要使用Redis。因此，这个问题主要从性能和并发两个角度考虑。</p> <h3 id="性能"><a href="#性能" aria-hidden="true" class="header-anchor">#</a> 性能</h3> <div style="text-align:center;"><img src="/assets/img/xingneng.86b908f9.jpg" style="height:250px;width:500px"></div> <p>如图所示，当碰到执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存中。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。</p> <h3 id="并发"><a href="#并发" aria-hidden="true" class="header-anchor">#</a> 并发</h3> <div style="text-align:center; "><img src="/assets/img/bingfa.0b4efb8f.jpg" style="height:250px;width:500px"></div> <p>如图所示，当大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用Redis做一个缓冲作用，让请求先访问Redis，而不是直接访问数据库。</p> <h2 id="使用redis有什么缺点"><a href="#使用redis有什么缺点" aria-hidden="true" class="header-anchor">#</a> 使用Redis有什么缺点</h2> <p>使用Redis基本会碰到一些问题，最常见的四个问题：<code>1.缓存和数据库双写一致性问题；2.缓存雪崩问题；3.缓存击穿问题；4.缓存的并发竞争问题</code></p> <h2 id="单线程的redis为什么这么快"><a href="#单线程的redis为什么这么快" aria-hidden="true" class="header-anchor">#</a> 单线程的Redis为什么这么快</h2> <p>其实Redis是单线程工作模式， Redis读写快的原因主要有：<code>1.纯内存操作；2.单线程操作，避免了频繁的上下文切换；3.采用了非阻塞I/O多路复用机制</code>。</p> <p>I/O多路复用的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。</p> <h2 id="redis-的数据类型"><a href="#redis-的数据类型" aria-hidden="true" class="header-anchor">#</a> Redis 的数据类型</h2> <p>开头介绍Redis是一个Key - Value存储系统，value类型有String、Set、Sorted Set、Hash和List。这里介绍Redis中的五种数据类型及其每种数据类型使用的场景。</p> <ol><li><p>String：</p> <p>最常规的set/get操作，value可以是String，也可以是数字。一般做一些复杂的计数功能的缓存。</p></li> <li><p>Hash：</p> <p>value存放对象。</p></li> <li><p>List：</p> <p>使用 List 的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。</p></li> <li><p>Set：</p> <p>因为 Set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。 就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p></li> <li><p>Sorted Set：</p> <p>Sorted Set多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。</p></li></ol> <h2 id="redis-的过期策略以及内存淘汰机制"><a href="#redis-的过期策略以及内存淘汰机制" aria-hidden="true" class="header-anchor">#</a> Redis 的过期策略以及内存淘汰机制</h2> <p>这个问题相当重要，到底 Redis 有没用到家，这个问题就可以看出来。</p> <p>比如你 Redis 只能存 5G 数据，可是你写了 10G，那会删 5G 的数据。怎么删的，这个问题思考过么？</p> <p><strong>回答：Redis 采用的是定期删除+惰性删除策略。</strong></p> <p>还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?</p> <h3 id="为什么不用定时删除策略"><a href="#为什么不用定时删除策略" aria-hidden="true" class="header-anchor">#</a> 为什么不用定时删除策略</h3> <p>定时删除，用一个定时器来负责监视 Key，过期则自动删除。虽然内存及时释放，但是十分消耗 CPU 资源。在大并发请求下，CPU 要将时间应用在处理请求，而不是删除 Key，因此没有采用这一策略。</p> <h3 id="定期删除-惰性删除是如何工作"><a href="#定期删除-惰性删除是如何工作" aria-hidden="true" class="header-anchor">#</a> 定期删除+惰性删除是如何工作</h3> <p>定期删除，Redis 默认每个 100ms 检查，是否有过期的 Key，有过期 Key 则删除。需要说明的是，Redis 不是每个 100ms 将所有的 Key 检查一次，而是随机抽取进行检查(如果每隔 100ms，全部 Key 进行检查，Redis 岂不是卡死)。因此，如果只采用定期删除策略，会导致很多 Key 到时间没有删除。于是，惰性删除派上用场。也就是说在你获取某个 Key 的时候，Redis 会检查一下，这个 Key 如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。</p> <p>采用定期删除+惰性删除就没其他问题了么?</p> <p><strong>回答：不是的，如果定期删除没删除 Key。然后你也没即时去请求 Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高。那么就应该采用内存淘汰机制。</strong></p> <h3 id="内存淘汰机制"><a href="#内存淘汰机制" aria-hidden="true" class="header-anchor">#</a> 内存淘汰机制</h3> <ul><li><p><strong>noeviction</strong> ：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。</p></li> <li><p><strong>allkeys-lru</strong> ：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。<strong>推荐使用，目前项目在用这种。</strong></p></li> <li><p><strong>allkeys-random</strong> ：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。</p></li> <li><p><strong>volatile-lru</strong> ：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。</p></li> <li><p><strong>volatile-random</strong> ：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。</p></li> <li><p><strong>volatile-ttl</strong> ：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。</p></li></ul> <h2 id="redis-和数据库双写一致性问题"><a href="#redis-和数据库双写一致性问题" aria-hidden="true" class="header-anchor">#</a> Redis 和数据库双写一致性问题</h2> <p>一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。另外，我们所做的方案从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p> <p><strong>回答：首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列</strong>。</p> <h2 id="如何应对缓存穿透和缓存雪崩问题"><a href="#如何应对缓存穿透和缓存雪崩问题" aria-hidden="true" class="header-anchor">#</a> 如何应对缓存穿透和缓存雪崩问题</h2> <p><strong>缓存穿透</strong>，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p> <p>缓存穿透解决方案：<code>1.利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试；2.采用异步更新策略，无论 Key 是否取到值，都直接返回。Value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作；3.提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 Key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。</code></p> <p><strong>缓存雪崩</strong>，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p> <p>缓存雪崩解决方案：<code>1.给缓存的失效时间，加上一个随机值，避免集体失效；2.使用互斥锁，但是该方案吞吐量明显下降了；3.双缓存。我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。自己做缓存预热操作。然后细分以下几个小点：从缓存 A 读数据库，有则直接返回；A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程，更新线程同时更新缓存 A 和缓存 B。</code></p> <h2 id="如何解决-redis-的并发竞争-key-问题"><a href="#如何解决-redis-的并发竞争-key-问题" aria-hidden="true" class="header-anchor">#</a> 如何解决 Redis 的并发竞争 Key 问题</h2> <p>这个问题大致就是，同时有多个子系统去 Set 一个 Key。这个时候大家思考过要注意什么呢？</p> <h3 id="如果对这个-key-操作，不要求顺序"><a href="#如果对这个-key-操作，不要求顺序" aria-hidden="true" class="header-anchor">#</a> 如果对这个 Key 操作，不要求顺序</h3> <p>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可，比较简单。</p> <h3 id="如果对这个-key-操作，要求顺序"><a href="#如果对这个-key-操作，要求顺序" aria-hidden="true" class="header-anchor">#</a> 如果对这个 Key 操作，要求顺序</h3> <p>假设有一个 key1，系统 A 需要将 key1 设置为 valueA，系统 B 需要将 key1 设置为 valueB，系统 C 需要将 key1 设置为 valueC。期望按照 key1 的 value 值按照 valueA &gt; valueB &gt; valueC 的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下：</p> <div class="language- extra-class"><pre class="language-text"><code>系统A key 1 {valueA  3:00}
系统B key 1 {valueB  3:05}
系统C key 1 {valueC  3:10}
</code></pre></div><p>那么，假设这会系统 B 先抢到锁，将 key1 设置为<code>{valueB 3:05}</code>。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了，以此类推。</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.05c1b046.js" defer></script><script src="/assets/js/7.3e2104db.js" defer></script>
  </body>
</html>
